import socket from '../../services/websocket';
import { updateSlotStatus, fetchShelfStatusSuccess } from '../slices/shelfSlice';
import { addOperationToHistory } from '../slices/operationSlice';
import { addNotification } from '../slices/notificationSlice';
import { logger } from '../../utils/logger';

// This will be set by the useWebSocket hook to allow the middleware to call its handler
let handleOperationResponseCallback = null;

export const setHandleOperationResponseCallback = (callback) => {
  handleOperationResponseCallback = callback;
};

const websocketMiddleware = (store) => (next) => (action) => {
  switch (action.type) {
    case 'websocket/connect':
      socket.connect();
      break;
    case 'websocket/disconnect':
      socket.disconnect();
      break;
    case 'websocket/joinShelf':
      socket.emit('join_shelf', action.payload);
      break;
    case 'websocket/operationRequest':
      // The payload now contains the requestId generated by useWebSocket
      socket.emit('operation_request', action.payload);
      break;
    default:
      break;
  }

  // Handle incoming WebSocket messages
  socket.on('system_event', (payload) => {
    logger.info('Received system_event:', payload);
    const { type, data } = payload;
    let notificationMessage = '';

    switch (type) {
      case 'inventory_update':
        const { shelfId, slotId, materialId } = data;
        let newStatus;
        if (data.type === 'material_placed') {
          newStatus = 'occupied';
          notificationMessage = `Material ${materialId} placed in slot ${slotId} on shelf ${shelfId}.`;
        } else if (data.type === 'material_removed') {
          newStatus = 'empty';
          notificationMessage = `Material removed from slot ${slotId} on shelf ${shelfId}.`;
        } else if (data.type === 'material_moved') {
          newStatus = 'occupied'; // Assuming target slot becomes occupied
          notificationMessage = `Material ${materialId} moved from ${data.fromSlotId} to ${slotId} on shelf ${shelfId}.`;
        }
        store.dispatch(updateSlotStatus({ slotId, newStatus, materialId }));
        store.dispatch(addOperationToHistory({ ...data, type: data.type }));
        break;
      case 'shelf_status':
        store.dispatch(fetchShelfStatusSuccess(data)); // Update shelf status in store
        notificationMessage = `Shelf ${data.shelfId} status: ${data.status}`;
        break;
      case 'shelf_status_changed':
        notificationMessage = `Shelf ${data.shelfId} status changed from ${data.oldStatus} to ${data.newStatus}.`;
        break;
      case 'health_alert':
        notificationMessage = `Health Alert for Shelf ${data.shelfId}: ${data.message} (Severity: ${data.severity})`;
        break;
      case 'system_alert':
        notificationMessage = `System Alert: ${data.message} (Type: ${data.type}, Severity: ${data.severity})`;
        break;
      case 'audit_log':
        notificationMessage = `Audit Log: ${data.action} by ${data.operatorId}`; // Customize as needed
        break;
      case 'shelf_message':
        notificationMessage = `Message from Shelf ${data.shelfId}: ${data.text}`;
        break;
      case 'critical_system_alert':
        notificationMessage = `CRITICAL SYSTEM ALERT: ${data.message}`;
        break;
      case 'physical.placement.confirmed': // New event type
        notificationMessage = `Physical placement confirmed for operation ${data.operation_id}.`;
        // Update slot status and operation history based on confirmed data
        store.dispatch(updateSlotStatus({ slotId: data.slot_id, newStatus: 'occupied', materialId: data.material_id }));
        store.dispatch(addOperationToHistory({ ...data, type: 'placement_confirmed', status: 'completed' }));
        break;
      case 'physical.placement.failed': // New event type
        notificationMessage = `Physical placement failed for operation ${data.operation_id}. Slot rolled back.`;
        // Update slot status and operation history based on failed data
        store.dispatch(updateSlotStatus({ slotId: data.slot_id, newStatus: 'empty', materialId: null }));
        store.dispatch(addOperationToHistory({ ...data, type: 'placement_failed', status: 'failed' }));
        break;
      default:
        logger.warn(`Unknown system event type received: ${type}`, payload);
        notificationMessage = `Received unknown event: ${type}`;
    }

    if (notificationMessage) {
      store.dispatch(addNotification(notificationMessage));
    }
  });

  socket.on('operation_response', (payload) => {
    logger.info('Received operation_response:', payload);
    // Call the handler provided by useWebSocket to resolve/reject the promise
    if (handleOperationResponseCallback) {
      handleOperationResponseCallback(payload);
    }
  });

  socket.on('connect_error', (error) => {
    logger.error('WebSocket connect_error:', error);
    store.dispatch(addNotification(`WebSocket connection error: ${error.message}`));
  });

  socket.on('error', (error) => {
    logger.error('WebSocket error:', error);
    store.dispatch(addNotification(`WebSocket error: ${error.message}`));
  });

  return next(action);
};

export default websocketMiddleware;